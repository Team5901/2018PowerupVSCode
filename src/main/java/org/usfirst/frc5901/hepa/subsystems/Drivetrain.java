	// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5901.hepa.subsystems;

import org.usfirst.frc5901.hepa.Robot;
import org.usfirst.frc5901.hepa.commands.TeleopArcadeDriveCommand;
import org.usfirst.frc5901.hepa.RobotMap;
import org.usfirst.frc5901.hepa.commands.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.Timer;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import edu.wpi.first.wpilibj.RobotDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Drivetrain extends Subsystem {
	private final ADXRS450_Gyro godKevinGyro = RobotMap.drivetrainGodRicardoGyro;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final WPI_TalonSRX leftfront = RobotMap.drivetrainLeftfront;
    private final WPI_TalonSRX leftrear = RobotMap.drivetrainLeftrear;
    private final WPI_TalonSRX rightfront = RobotMap.drivetrainRightfront;
    private final WPI_TalonSRX rightrear = RobotMap.drivetrainRightrear;
    private final RobotDrive robotDrive41 = RobotMap.drivetrainRobotDrive41;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    double leftMotorSpeed;
    double rightMotorSpeed;
    double move;
    double rotate;
    @Override
    public void initDefaultCommand() {
    	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	setDefaultCommand(new TeleopArcadeDriveCommand()); 	
        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }

    @Override
    public void periodic() {
        // Put code here to be run every loop

    } 
    //%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //%%%%%%%%%% PARAMETERS %%%%%%%%%%
 	//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    double turnRatio = 0.03; 						//Higher = faster gyro turning, but more oscillation
    private static double precisionDriveAmount=0.7;
    double turnSensitivity=0.5;
    private static double ElevatorDriveSpeed = 0.4;
    
    
    //%%%%%%%%%% Sets motor outputs %%%%%%%%%%
	private void setMotorOutputs(double leftSpeed, double rightSpeed){
		leftfront.set(leftSpeed);
		rightfront.set(rightSpeed);
		leftrear.set(leftSpeed);
		rightrear.set(rightSpeed);
	}
	
	//%%%%%%%%%% Limits maximum turning rate %%%%%%%%%%
	private static double limitTurn(double num) {
        if (num > 0.5) {
            return 0.5;
        }
        else if (num < -0.5) {
            return -0.5;
        }
        else{
        	return num;
        }
    }
	
	//%%%%%%%%%% Limits maximum motor output to 1.0 %%%%%%%%%%
	private static double limit(double num) {
        if (num > 1.0) {
            return 1.0;
        }
        else if (num < -1.0) {
            return -1.0;
        }
        else{
        	return num;
        }
    }
	
	//%%%%%%%%%% Ignores input if joystick is barely off center %%%%%%%%%%
    private static double deadzone(double num){
    	if (Math.abs(num) < 0.2){
    		return 0;
    	}
		else {
			return num;
    	}
    }
    
    //%%%%%%%%%% Sets left and right motor speeds according to joystick %%%%%%%%%%
    public void cougarDrive(double moveValue, double rotateValue) {      
        leftMotorSpeed = limit(moveValue - rotateValue);
        rightMotorSpeed = limit(moveValue + rotateValue);
        setMotorOutputs((leftMotorSpeed), (rightMotorSpeed));
    }
    
    //%%%%%%%%%% Main driving command - uses deadzones, and has turbo button. Press for slower control %%%%%%%%%%
	public void drive(){
		
		move = Robot.oi.connieJS1.getRawAxis(1);
		rotate = Robot.oi.connieJS1.getRawAxis(4);
		
		move = move*move*move;
		rotate = rotate*rotate*rotate;
		
        move = deadzone(move);
        rotate = deadzone(rotate);
		
		if (RobotMap.elevatorEbony1.getSensorCollection().getQuadraturePosition() > 10000) {
			cougarDrive(move*ElevatorDriveSpeed,rotate*ElevatorDriveSpeed);
		}
		
		else if (Robot.oi.connieJS1.getRawButton(6)){
			cougarDrive(move, rotate);
		}
		else{					
			cougarDrive(move*precisionDriveAmount, rotate*precisionDriveAmount);
		}		
	}
	
	//%%%%%%%%%% Stops all motors %%%%%%%%%%
	public void stopDrive(){
		cougarDrive(0.0,0.0);
	}
	
	//%%%%%%%%%% Turn to an angle in autonomous %%%%%%%%%%
	public void autoTurn(double angleTarget){
		double angle = godKevinGyro.getAngle(); 						// get current heading
		double target = angle + angleTarget;
		
		if( target < -1 || target > 1) {	
			cougarDrive(0.0, -limitTurn((target)*turnRatio)-Math.signum(target)*.07); 		// turn towards angleTarget
			Timer.delay(0.004);	    
		}
	}
	
	//%%%%%%%%%% Drive backwards in autonomous %%%%%%%%%%
	public void autoBackwards(double speed){
		 double angle = godKevinGyro.getAngle(); 				// get current heading
		 cougarDrive(speed, -angle*turnRatio); 					// drive backwardsheading 0
		 Timer.delay(0.004);
	}
	
	//%%%%%%%%%% Drive straight in autonomous %%%%%%%%%%
	public void autoStraight(double speed){
		 double angle = godKevinGyro.getAngle(); 				// get current heading
		 cougarDrive(-speed, -angle*turnRatio); 				// drive towards heading 0
		 Timer.delay(0.004);
	}
	
	public void autoaim() {
		NetworkTable table = NetworkTableInstance.getDefault().getTable("limelight");
		NetworkTableEntry tx = table.getEntry("tx");
		NetworkTableEntry ta = table.getEntry("ta");		
		NetworkTableEntry tv = table.getEntry("tv");
		
		double x = tx.getDouble(0);
		double area = ta.getDouble(0);
		double targetExist = tv.getDouble(0);
		
		System.out.println("Attempting Autoaim..." + targetExist);
		//if (targetExist==1) {
			if( x < -1 || x > 1) {
				System.out.println("AutoAim: "+ x);
				cougarDrive(0.2,limitTurn(x*.04)+Math.signum(x)*.07); 						// turn towards angleTarget
				Timer.delay(0.004);	   
			}
		/*}
		else {
			System.out.println("TargetDoesntExist: "+ x);
			
		}*/
			
		

	}
}



